als = [
    "class SourceDoc(BaseModel):\n    model_config = ConfigDict(frozen=True)\n    source: SourceCode\n    doc_string: str | None",
    "def _get_source_code_from_name(self, obj_name: str) -> SourceCode | None:\n    func = list(self.indexer.index[obj_name])\n    if not func:\n        return None\n    if len(func) > 1:\n        print('Found multiple elements. Please select the proper one:')\n        for idx, item in enumerate(func):\n            print(f'{idx:<4}:{item.location}...')\n        index = int(input('Type index: '))\n        object_def = func[index]\n    else:\n        object_def = func[0]\n    return object_def",
    "def _get_arg_from_binop(self, op: ast.BinOp) -> set[str]:\n    arg_types: set[str] = set()\n    for nest_op in [op.left, op.right]:\n        if isinstance(nest_op, ast.Name):\n            arg_types.add(nest_op.id)\n        if isinstance(nest_op, ast.BinOp):\n            sub_types = self._get_arg_from_binop(nest_op)\n            arg_types.update(sub_types)\n    return arg_types",
    "def _get_call_tree(self, node: ast.FunctionDef | ast.ClassDef, visited: set[str]=None, recursive: bool=False) -> set[str]:\n    visited: set[str] = visited or set()\n    call_names: set[str] = set()\n    call_finder = CallFinder(call_names)\n    call_finder.visit(node)\n    if recursive:\n        for call in deepcopy(call_names):\n            dep_node = self.index.get(call, set())\n            if not dep_node:\n                continue\n            for sub_node in dep_node:\n                if sub_node.object_name in visited:\n                    continue\n                visited.add(sub_node.object_name)\n                sub_calls = self._get_call_tree(ast.parse(sub_node.source_code), recursive=recursive, visited=visited)\n                call_names.update(sub_calls)\n    return call_names",
    "class CallFinder(ast.NodeVisitor):\n\n    def __init__(self, call_names: set[str]) -> None:\n        self.call_names: set[str] = call_names\n\n    def visit_FunctionDef(self, node: ast.FunctionDef):\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef):\n        self.generic_visit(node)\n\n    def visit_Call(self, node: ast.Call):\n        if isinstance(node.func, ast.Name):\n            self.call_names.add(node.func.id)\n        if isinstance(node.func, ast.Attribute):\n            self.call_names.add(node.func.attr)",
    "def get_dependencies(self, func_name: str, recursive: bool=False) -> list[str] | None:\n    func = self.index.get(func_name)\n    if not func:\n        return None\n    node = ast.parse(list(func)[0].source_code)\n    if isinstance(node, ast.Module):\n        node = node.body[0]\n    call_names = self._get_call_tree(node, recursive=recursive)\n    arg_types: set[str] = set()\n    for call in chain([func_name], call_names):\n        source = self.index.get(call)\n        if source:\n            for obj in source:\n                source_code = ast.parse(obj.source_code)\n                if isinstance(source_code, ast.Module):\n                    source_code = source_code.body[0]\n                if not isinstance(source_code, ast.FunctionDef):\n                    continue\n                args = self._get_args(source_code)\n                if args:\n                    arg_types.update(args)\n        if not recursive:\n            break\n    dependencies: list[SourceCode] = []\n    for dep in chain(call_names, arg_types):\n        if dep not in self.index:\n            continue\n        dependencies.extend(list(self.index[dep]))\n    dependencies_src: list[str] = [x.source_code[:3000] for x in dependencies]\n    return dependencies_src",
    "def _handle_doc_generation(self, function_name: str | None=None, object_def: SourceCode | None | BaseModel=None, pbar: tqdm | None=None, custom_instruction: str | None=None) -> SourceDoc | None:\n    if pbar:\n        pbar.update(1)\n    if not function_name and (not object_def):\n        raise ValueError('Please provide a function name or an object_def')\n    source_code = object_def or self._get_source_code_from_name(function_name)\n    if not source_code:\n        print('ERROR: Unable to locate object in the index. Double check the name you entered.')\n        return None\n    obj_name = source_code.object_name\n    dependencies = self.indexer.get_dependencies(obj_name)\n    try:\n        doc_string = self._generate_doc(obj_name, source_code.source_code, dependencies, silence=bool(pbar), custom_instruction=custom_instruction)\n    except Exception as e:\n        print(e)\n        print('Unable to generate doc string')\n        return None\n    if not doc_string:\n        print('Unable to generate doc string')\n    doc_string = doc_string.strip(' \\'\"\\n')\n    doc_string = '\"\"\"\\n' + doc_string + '\\n\"\"\"'\n    return SourceDoc(doc_string=doc_string, source=source_code)",
    "def _generate_doc(self, func_name: str, func_code: str, dependencies: list[str] | None, silence: bool=False, custom_instruction: str | None=None):\n    if not silence:\n        print(f\"Generating docstrings for '{func_name}'\")\n    client = OpenAI(timeout=30)\n    if not dependencies:\n        dependencies = []\n\n    class Step(BaseModel):\n        \"\"\"#pythion:ignore\"\"\"\n        why_does_this_object_exist: str | None = None\n        what_purpose_does_it_serve: str | None = None\n\n    class DocString(BaseModel):\n        \"\"\"#pythion:ignore\"\"\"\n        steps: list[Step]\n        main_object_name: str\n        main_object_docstring: str\n    messages = [{'role': 'system', 'content': \"You are a Python docstring writer. Your task is to look at the main object, it's arguments, dependencies and write a docstring for the main object. Only share the the docstring for the main object.\\n\\nThe format I want is Google Style. Format neatly with list items (if any). Keep documentation simple, minimal and don't repeat the obvious.\"}, {'role': 'user', 'content': 'Main Object Name: ' + func_name}, {'role': 'user', 'content': 'Main Object source code: ' + func_code}, {'role': 'user', 'content': 'Dependency Source code: ' + '\\n\\n'.join(dependencies)}]\n    if custom_instruction:\n        messages.append({'role': 'user', 'content': 'Additional Instructions: ' + custom_instruction})\n    completion = client.beta.chat.completions.parse(model='gpt-4o-mini', messages=messages, response_format=DocString)\n    ai_repsonse = completion.choices[0].message\n    if not ai_repsonse.parsed:\n        return None\n    return ai_repsonse.parsed.main_object_docstring",
    "def _get_args(self, node: ast.FunctionDef) -> set[str] | None:\n    if not isinstance(node, ast.FunctionDef):\n        return None\n    arg_types: set[str] = set()\n    for arg in node.args.args:\n        if isinstance(arg.annotation, ast.Name):\n            arg_types.add(arg.annotation.id)\n        if isinstance(arg.annotation, ast.BinOp):\n            sub_types = self._get_arg_from_binop(arg.annotation)\n            arg_types.update(sub_types)\n    return arg_types",
    "class SourceCode(BaseModel):\n    object_name: str\n    object_type: Literal['function'] | Literal['class']\n    file_path: str\n    source_code: str\n    has_docstring: bool\n\n    @property\n    def location(self) -> str | None:\n        loc = find_object_location(self.file_path, self.object_name, self.object_type)\n        if not loc:\n            return None\n        return loc.vscode_link\n\n    def __eq__(self, value: object) -> bool:\n        if not isinstance(value, SourceCode):\n            return False\n        return repr(self) == repr(value)\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __repr__(self) -> str:\n        return f'{self.file_path}:{self.object_name}:{self.source_code[15:]}'"
]